---
layout: single
title:  "힙(Heap)"
toc: true
author_profile: false
categories: Tree
tags: "python"
sidebar:
    nav: "counts"
toc_sticky: true
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
  <meta name="robots" content="noindex, nofollow" />
</head>
<span style="font-size:13px;">
해당 포스팅은 코드잇의 강의를 참고하였습니다.
<br><br><br>
# 힙(Heap)이란?
<span style = "font-weight:bold;">
힙(Heap)은 트리의 데이터에서 최댓값과 최솟값을 빠르고 효율적으로 찾기 위해 사용되는 특정 조건을 만족하는 완전 이진 트리이며 주로 우선순위 큐(priority queue)를 구현하거나 힙 정렬을 사용하는 데에 사용된다.</span><br><br>
데이터를 큐, 배열 등에 넣고 최대값이나 최소값을 찾으려면 최악의 경우 일일히 데이터를 검사해야 하기 때문에 O(n)의 시간 복잡도를 가지지만, 힙을 사용하면 시간 복잡도는 O(log n)으로 시간 복잡도가 현격하게 줄어든다.<br>
하지만 힙은 느슨한 정렬상태여서 완벽히 정렬되지 않는 경우가 많고 큐, 배열 등의 데이터 구조를 힙 구조로 바꾸는데 노력과 시간이 소모될 수 있다는 단점이 존재한다.


<br><br>
※ 힙의 노드에는 데이터의 중복이 허용된다.<br><br>
<img width="700" alt="image" src="https://github.com/gyun97/Java-Spring-Study/assets/143414166/6d773aac-442d-437a-9ea4-9f1a18f7912e"><br><br>

힙에는 두 가지 종류의 힙이 존재한다.<br><br>

## 1. 최대 힙(Max heap)
최대 힙(Max heap)은 다음의 두 조건을 만족해야 한다.
<br><br>

* <span style = "font-weight:bold;">조건 1. 완전 이진 트리여야 한다.</span>
* <span style = "font-weight:bold;">조건 2. 모든 부모 노드의 데이터는 자신의 자식 노드(들)의 데이터보다 크거나 같아야만 한다.</span> 

<img width="700" alt="image" src="https://github.com/gyun97/Java-Spring-Study/assets/143414166/f859c154-34c6-4da9-b9a3-d9e76b711025"><br><br>
<span style = "color:red; font-weight:bold;">루트 노드에는 항상 데이터들 중 가장 큰 값이 저장되어 최댓값을 O(1)만에 찾을 수 있다.</span>
<br><br><br>

## 2. 최소 힙(Min heap)
최소 힙(Min heap)은 다음의 두 조건을 만족해야 한다.
<br><br>

* <span style = "font-weight:bold;">조건 1. 완전 이진 트리여야 한다.</span>
* <span style = "font-weight:bold;">조건 2. 모든 부모 노드의 데이터는 자신의 자식 노드(들)의 데이터보다 작거나 같아야만 한다.</span>

<img width="700" alt="image" src="https://github.com/gyun97/Java-Spring-Study/assets/143414166/a78a6782-77c6-4fa5-b6d0-2e18059ad16f"><br><br>
<span style = "color:red; font-weight:bold;">루트 노드에는 항상 데이터들 중 가장 작은 값이 저장되어 최솟값을 O(1)만에 찾을 수 있다.</span>
<br><br><br>

# 배열로 구현한 힙
앞서 <a href="https://gyun97.github.io/tree/%ED%8A%B8%EB%A6%AC/">트리</a> 포스팅의 '리스트(동적 배열)로 완전 이진 트리 구현하기'에서 배열로 힙을 구현하였다.<br><br> 
<img width="700" alt="image" src="https://github.com/gyun97/Java-Spring-Study/assets/143414166/c74cc8c2-ee04-48cc-9172-6a5c1a280ebe">
<br><br>
```python
complete_binary_tree = [None, "A", "B", "C", "D", "E", "F", "G", "H", "I"]
```
(root 노드가 1번일 때)
* 왼쪽 자식의 인덱스: 인덱스 * 2
* 오른쪽 자식의 인덱스: 인덱스 * 2 + 1
* 부모 인덱스: 자식 인덱스 // 2
<br><br><br>


# heapify 함수
<span style = "font-weight:bold;">
heapify 함수는 힙 속성을 지키지 않는(최대 힙의 경우 부모보다 자식이 더 크거나 또는 최소 힙의 경우 부모보다 자식이 더 작은) 노드가 존재할 때 힙 속성을 지키게끔 노드들을 재배치하는 함수이다.</span><br><br>

heapify 함수의 과정을 이미지 예시로 살펴보자.<br><br>
<img width="700" alt="image" src="https://github.com/gyun97/Java-Spring-Study/assets/143414166/3375bcbb-92ba-46e3-9815-58a8e476e22f"><br>
위의 이미지의 완전 트리는 부모 데이터의 크기 조건을 충족하지 못하는 부분이 있어 힙이 아니다. 해당 완전 트리를 Heapify 함수를 이용하여 최대 힙으로 만드는 과정은 다음과 같다.<br><br>
<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/d00141a8-b940-4ac5-9fba-226b76307386">  
<br><br>
<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/6b1b972d-16c4-4bd9-9258-4a98fb697235"><br><br>
이러한 heapify 과정의 최악의 상황은 맨 위의 루트 노드부터 시작해서 맨 마지막 leaf 노드까지 heapify가 이루어지는 경우이다.<br>
<span style = "font-weight:bold;">
즉, 최악의 경우 해당 트리의 높이만큼 트리의 데이터를 비교하여 재배치하여야 하기 때문에 heapify 함수의 시간 복잡도는 완전 이진 트리의 높이인 O(log(N))이다.</span><br><br>

부모와 자식 노드들 중 최댓값을 부모 노드로 보내는 heapify 함수를 파이썬 코드로 구현하면 다음과 같다.<br>
```python
def max_heap_heapify(tree, init_index, tree_size):
    """tree: 사용할 이진 트리, init_index: heapify 하려고 하는 인덱스(부모 노드), tree_size: 트리 크기"""

    # 왼쪽 자식 노드의 인덱스와 오른쪽 자식 노드의 인덱스
    left_child_index = 2 * init_index
    right_child_index = 2 * init_index + 1

    largest = init_index  # 초기의 최댓값은 heapify 파라미터로 넘긴 부모 노드로 가정

    # 부모 노드와 왼쪽 자식 노드의 값과 비교해서 왼쪽 자식이 더 클 시 최댓값 노드 갱신
    if 0 < left_child_index < tree_size and tree[largest] < tree[left_child_index]:
        largest = left_child_index

    # 최댓값 노드와 오른쪽 자식 노드의 값 비교해서 오른쪽 자식 노드가 더 클 시 최댓값 노드 갱신
    if 0 < right_child_index < tree_size and tree[largest] < tree[right_child_index]:
        largest = right_child_index

    if largest != init_index:  # 부모 노드의 값((파라미터))이 자식 노드의 값보다 작다면
        tree[init_index], tree[largest] = tree[largest], tree[init_index] # 부모 노드와 최댓값을 가진 자식 노드의 위치를 바꿔준다
        max_heap_heapify(tree, largest, tree_size)  # 자리가 바뀌어 자식 노드가 된 기존의 부모 노드를 대상으로 또 heapify 함수를 호출한다


# 테스트 코드
tree = [None, 24, 8, 19, 21, 10, 14, 7, 6, 17, 3]  # heapify하고자 하는 대상의 완전 이진 트리
max_heap_heapify(tree, 2, len(tree))  # 노드 2에 heapify 호출 -> 노드 2와 그 자식 노드들 heapify
print(tree)

# 테스트 결과
[None, 24, 21, 19, 17, 10, 14, 7, 6, 8, 3]
```
해당 코드를 통해 최대 힙 속성이 지켜지지 않은 부분의 노드들의 부모 노드를 파라미터로 넘겨 재배치할 수 있다.<br> 
만약 파라미터로 넘겨진 부모 노드와 그 자식 노드가 힙의 속성을 만족한다면 해당 코드는 아무 영향도 미치지 않으며 해당 코드만으로 이진 트리를 완전히 힙으로 만들 수는 없다는 점을 주의해야 한다.<br><br>

※ maxheap_heapify 함수에서의 부등호를 반대 방향으로 설정하면 마찬가지로 원하는 부분의 노드들이 최소 힙 속성(부모가 자식보다 작거나 같다)을 지키게끔 재배치하는 것이 가능하다.<br><br><br>

# heapify 함수를 이용한 힙 만들기
그렇다면 이 heapify 함수를 이용하여 어떻게 트리(배열)를 힙으로 만들 수 있을까??<br><br>

<span style = "font-weight:bold;">
맨 마지막 노드부터 루트 노드(1번 인덱스)까지 각 노드에서 heapify 함수를 호출하면 힙이 만들어진다.</span><br> 
heapify 함수의 코드 마지막 부분에 부모와 자식 노드간의 자리가 바뀌었으면 재귀를 통해 그 아래 노드들은 바뀐 배치를 고려하여 또 다시 heapify가 이루어지기 때문이다.<br>
<span style = "font-weight:bold;">
즉, 맨 뒤 노드부터 1번 노드까지 heapify 함수를 호출하면 1번 노드 아래의 부분 트리들은 모두 힙 속성을 충족하게 된다.</span><br><br><br>

위의 설명을 더 쉬운 이해를 위해 이미지 예시를 통해 설명하겠다.<br><br>
<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/f8cc20ae-2eb0-4c8e-9c02-f269146511c7">
<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/6c61ed5d-cd3f-4cc7-9efa-15ff11608094">
이미지와 같은 완전 이진 트리를 리스트로 구현한 후 맨 뒤의 원소부터 루트 노드인 1번 인덱스까지 각 노드에서 heapify 함수를 호출한다.<br>
10~6번 인덱스까지는 자식이 없는 leaf 노드이고 5~3번 인덱스까지는 최대 힙의 속성을 잘 지키고 있어 heapify 함수를 호출해도 아무런 영향이 없다.<br><br>

하지만 힙 속성이 지켜지지 않고 있는 2번 인덱스의 차례에서 heapify 함수를 호출하면 자리 교환이 일어나고 이후 재귀호출을 통해 2번 노드의 부분 트리에서 노드들의 재배치가 연쇄적으로 이루어진다.<br><br>

<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/e17bea86-539d-4149-a519-de1471d68174"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/ea6c3e5b-4077-47ff-b16c-ea4a43249f28"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/fca308fe-8e02-4252-8a00-421b0988181c"><br><br>

이러한 원리 때문에 맨 마지막 원소부터 1번 인덱스의 원소(루트 노드)까지 차례로 heapify 함수를 호출하면(파라미터로 인덱스를 넘겨주면) 힙이 완성되는 것이다. 