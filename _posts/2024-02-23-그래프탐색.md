---
layout: single
title:  "그래프 탐색: BFS와 DFS"
toc: true
author_profile: false
categories: Graph
tags: "python"
sidebar:
    nav: "counts"
toc_sticky: true
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
  <meta name="robots" content="noindex, nofollow" />
</head>
<span style="font-size:13px;">
해당 포스팅은 코드잇의 강의를 참고하였습니다.</span>
<br><br><br>

그래프 탐색에 대해 이해하기 위해서는 큐와 스택에 대한 지식이 선행되어야 합니다. 큐와 스택에 대한 기본 지식이 부족하다면 본 블로그의 해당 포스팅 <a href="https://gyun97.github.io/data_structure/%ED%81%90%EC%99%80-%EC%8A%A4%ED%83%9D/">큐(Queue)와 스택(Stack)</a>을 읽고 오는 것을 권장합니다. 

<br><br><br>

# 그래프 탐색이란?
일반적으로 자료 구조에서의 탐색은 주어진 조건을 만족하는 데이터를 찾아내는 것을 의미한다. 하지만 그래프에서는 탐색의 의미가 조금 다르다.<br><br>
<span style = "font-weight:bold;">
그래프에서의 탐색이란 한 시작점 노드(정점)에서 연결된 모든 노드를 찾는 것이다.</span><br>그래프의 노드들은 링크드 리스트, 트리 등의 다른 비선형적 자료구조와 달리 모든 노드들이 동등한 객체이기 때문에 시작점은 우리가 임의로 정해야 한다.<br><br>

흔히 자료 구조 안에 저장된 모든 데이터를 한 바퀴 도는 것을 순회라고 표현하는데 그래프 탐색도 특정 한 노드에서 연결된 모든 노드들을 다 돌기 때문에 '그래프 순회'라고 표현하기도 한다.
<br><br><br>

## 그래프 탐색의 의의
그래프 탐색을 그래프의 구조에 대해 여러 가지 의미 있는 정보들을 파악할 수 있다.<br><br>
<span style = "font-weight:bold;">
1.두 노드의 연결(인접) 여부 확인</span><br>
<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/db227aa0-92a5-4fe2-822c-95d3617a5dad"><br><br><br>
<span style = "font-weight:bold;">
2.두 노드간의 최단 경로 구하기</span>
<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/d41d636d-5d89-4a90-a596-2cab504f6e92"><br><br>

그래프의 두 노드간의 최단 경로를 구하는 내용은 다음 포스팅에서 자세하게 다룰 것이다.
<br><br><br><br><br>

# 그래프 탐색의 종류
<span style = "font-weight:bold;">
그래프 탐색은 각 노드들을 어떤 순서에 따라 탐색하냐에 다라서 <span style = "color:red;">BFS</span>와 <span style = "color:red;">DFS</span>의 2가지 종류로 나뉜다.</span><br><br><br>


## 1. BFS(Breadth First Search)
<span style = "font-weight:bold;">
BFS란 "Breadth(너비) First Search" 즉, 그래프의 너비를 우선적으로 탐색하는 방법이다. 여기서의 너비란 높이, 깊이와 반대되는 개념으로 가로 방향, 수평 방향이라고 생각하면 된다.</span><br><br>

우선 탐색 시작 노드를 정하고 시작 노드와 인접한 노드들을 수평(가로) 방향으로 탐색한다. 시작 노드와 인접해 있는 모든 노드들의 탐색이 끝났으면 시작 노드를 제외하고 가장 먼저 탐색이 끝난 노드들과 인접한 노드들부터 다시 수평 방향으로 탐색한다. 탐색이 가능한 모든 노드들의 탐색이 끝날 때까지 이러한 탐색 과정을 반복한다.<br><br>
<span style = "font-weight:bold;">
즉 BFS란 시작 노드에서 가장 가까운 노드들부터 탐색을 시작해서 가장 멀리 있는 노드들까지 수평 방향으로 탐색을 반복하는 과정이다.</span><br><br>    

<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/90c7df73-2a1b-4032-9578-302f8e03ea3d">
<br><br><br>

### BFS 알고리즘

위에서 예시로 들었던 그래프를 BFS가 어떤 알고리즘으로 탐색해는지 살펴보자.<br><br>
<span style = "font-weight:bold;"> 
BFS에서는 <span style = "color:red;"> 큐</span>를 사용한다.</span><br><br>
A 노드부터 BFS 탐색을 시작하는 예시 그래프와 한 개의 빈 큐가 있다고 가정해보자.<br><br>

<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/a13b0087-5061-453f-acbb-b1421891999c">
<br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/c11606a8-8986-4f1e-b031-607bfe30dd8f"><br><br>

<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/f737684b-38d5-4224-94ee-4c0103ee752e">
<br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/47cbedc7-e3ac-4234-a2dd-1ebd727e690c"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/14d90b3f-b3ff-430e-811c-5ce2defa06ae"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/eb5dc6f7-8594-4f0f-834b-93fae9b05a16"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/07fe25df-b8cc-4e5c-8246-73b366a7d9cd"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/cc1d71d1-9310-4daf-ae6b-c3d74feaa3c5"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/a1bb2274-d3c7-495b-ad08-f4b5dfb2e44d"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/96c9cb0f-ce9e-463e-af67-3026f6753f12"><br><br>

<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/e9bce45f-38d5-4f09-b36a-6c19d7a8985b"><br><br>


<img width="700" alt="image" src="https://github.com/gyun97/Baekjoon_Solution/assets/143414166/b88e2106-8bea-4262-adc8-1f708b1842cd"><br><br><br>

BFS 알고리즘을 정리하자면 다음과 같다.<br><br><br>


1.<span style = "font-weight:bold;"> 시작 노드를 방문 표시한 후 큐에 삽입한다.</span><br>
2.<span style = "font-weight:bold;"> 큐에 모든 노드가 비워질 때까지 다음 과정을 반복한다:</span>
- <span style = "font-weight:bold;"> 큐의 가장 앞 노드를 꺼낸다.</span>
- <span style = "font-weight:bold;"> 해당 노드와 인접한 아직 방문하지 않은 노드들을 방문 표시하고 큐에 삽입한다.</span>


